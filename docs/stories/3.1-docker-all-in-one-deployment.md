# Story 3.1 — Docker All‑in‑One Deployment (Render)

Owner: Scrum Master

## Summary

Deploy the Blackletter stack as a single Dockerized service on Render. The container runs Nginx on `$PORT` and reverse‑proxies to two internal processes: Next.js (SSR) on `:3000` and FastAPI (Uvicorn) on `:8000`. This keeps a single public endpoint, avoids CORS, and preserves full Next.js SSR/ISR capability.

## Goals & Non‑Goals

- Goals:
  - Single public service on Render using Docker.
  - Preserve Next.js SSR/ISR and FastAPI service.
  - Same‑origin routing: `/api/*` → FastAPI, everything else → Next.js.
- Non‑Goals:
  - Serverless API functions on Vercel.
  - Data layer changes (DB, queues) — out of scope.

## Architecture

- Nginx listens on `$PORT` (provided by Render).
- Upstreams:
  - `frontend`: Next.js `next start -p 3000` (SSR output of `next build`).
  - `api`: Uvicorn `blackletter_api.main:app` on `:8000`.
- Routing:
  - `/api/` and `/api/*` → `api` upstream.
  - All other paths → `frontend` upstream.

## Acceptance Criteria

1. Deploys on Render as a single Web Service (Docker) and passes health check.
2. `GET /` serves the landing page (SSR) with assets loading.
3. `GET /api` returns `{ "status": "ok" }` from FastAPI.
4. No CORS warnings in browser console (same origin).
5. Logs show three healthy processes (Nginx, Next.js, Uvicorn) with graceful shutdown.
6. Build is reproducible from clean checkout (no local artifacts required).

## Implementation Plan (Dev‑Ready)

### 1) Add Docker runtime files

Create a new folder `deploy/docker/` with:

- `Dockerfile` (multi‑process image: Node + Python + Nginx)
- `nginx.conf.template` (uses `$PORT` and proxies to 3000/8000)
- `start.sh` (envsubst the template and start all processes; keep Nginx in foreground)

Suggested contents:

```Dockerfile
# deploy/docker/Dockerfile
FROM node:20-bookworm

# System deps
RUN apt-get update \
  && apt-get install -y --no-install-recommends \
     python3 python3-pip nginx gettext-base \
  && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy monorepo files
COPY package.json package-lock.json ./
COPY apps/web/package.json apps/web/package.json
COPY apps/api/requirements.txt apps/api/requirements.txt

# Install web deps (hoisted at root or per-app depending on your setup)
RUN npm install --prefix apps/web

# Build Next.js
COPY apps/web apps/web
RUN npm run build --prefix apps/web

# Install Python deps
COPY apps/api apps/api
RUN pip install --no-cache-dir -r apps/api/requirements.txt

# Nginx & launcher
COPY deploy/docker/nginx.conf.template /etc/nginx/templates/default.conf.template
COPY deploy/docker/start.sh /start.sh
RUN chmod +x /start.sh

# Render provides $PORT; expose for local run
EXPOSE 8080

ENV HOST=0.0.0.0 \
    NEXT_PORT=3000 \
    API_PORT=8000

CMD ["/start.sh"]
```

```nginx
# deploy/docker/nginx.conf.template
user  nginx;
worker_processes auto;

events { worker_connections 1024; }

http {
  include       mime.types;
  default_type  application/octet-stream;
  sendfile      on;
  keepalive_timeout 65;
  client_max_body_size 20m;
  access_log /dev/stdout;
  error_log  /dev/stderr warn;

  upstream frontend {
    server 127.0.0.1:${NEXT_PORT};
  }

  upstream api {
    server 127.0.0.1:${API_PORT};
  }

  server {
    listen ${PORT};
    server_name _;

    # API routes
    location ^~ /api/ {
      proxy_pass http://api/;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Everything else → Next.js
    location / {
      proxy_pass http://frontend/;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }
  }
}
```

```bash
# deploy/docker/start.sh
#!/usr/bin/env bash
set -euo pipefail

: "${PORT:=8080}"
: "${NEXT_PORT:=3000}"
: "${API_PORT:=8000}"

# Render supplies $PORT; template Nginx conf
envsubst '${PORT} ${NEXT_PORT} ${API_PORT}' < \
  /etc/nginx/templates/default.conf.template > /etc/nginx/conf.d/default.conf

# Start Uvicorn (FastAPI). Use --app-dir since apps/ isn't a package.
uvicorn blackletter_api.main:app \
  --app-dir apps/api \
  --host 0.0.0.0 --port "${API_PORT}" --workers 2 &

# Start Next.js in production mode
npm run start --prefix apps/web -- --port "${NEXT_PORT}" &

# Trap to shutdown background processes cleanly
term_handler() {
  echo "Shutting down..."
  pkill -TERM -P $$ || true
  exit 0
}
trap term_handler SIGTERM SIGINT

# Start Nginx in foreground
nginx -g 'daemon off;' &
wait -n || true
```

### 2) Next.js config for production

No special config required. Optional: set `output: 'standalone'` in `apps/web/next.config.ts` to slim runtime, but `next start` works as-is.

### 3) API readiness

- Ensure `apps/api/blackletter_api/main.py` imports only existing routers. Currently it references `analyses`; add that file or remove the include.
- CORS not needed (same origin via Nginx).

### 4) Render configuration

Create `render.yaml` at repo root for one‑click deploy, or configure via dashboard:

```yaml
# render.yaml (root)
services:
  - type: web
    name: blackletter-all-in-one
    env: docker
    plan: starter
    autoDeploy: true
    healthCheckPath: /
    envVars:
      - key: PORT
        value: 8080
```

Dashboard equivalent:
- New → Web Service → Pick repo → Environment: Docker.
- Health check path `/`.
- No build command (Dockerfile controls build).

### 5) Local test

```bash
docker build -f deploy/docker/Dockerfile -t blackletter-all-in-one .
docker run -p 8080:8080 blackletter-all-in-one
# Open http://localhost:8080 → landing
# Open http://localhost:8080/api → {"status":"ok"}
```

## Risks & Mitigations

- Multi‑process management: supervised via Nginx foreground + background Next/Uvicorn. Mitigate with health checks and logs; can switch to supervisord if needed.
- Port collisions: templated ports avoid conflicts; only Nginx binds `$PORT`.
- Build size: Node+Python+Nginx base is larger. Optionally multi‑stage and copy Next standalone output.

## Dev Agent Record

Use this checklist to drive the cycle. Only update this section during implementation.

- [ ] Add `deploy/docker/Dockerfile` matching the spec above.
- [ ] Add `deploy/docker/nginx.conf.template` matching the spec above.
- [ ] Add `deploy/docker/start.sh` and make it executable.
- [ ] Fix API router import: remove or implement `routers/analyses.py`.
- [ ] Build and run locally; verify `/` and `/api`.
- [ ] Add root `render.yaml` for one‑click deploy.
- [ ] Create Render Web Service from repo, env: Docker, health check `/`.
- [ ] Confirm deployment green; capture logs and URLs.
- [ ] Update `apps/web/README.md` with Docker/Render run notes.
- [ ] Document rollback (redeploy previous image) in `docs/deployment/`.

## Definition of Done

- A single Render Web Service publicly serves both the Next.js site and FastAPI under one domain.
- Source of truth includes Dockerfile, Nginx template, and start script committed to the repo.
- README and story updated with deployment steps and verification evidence.
